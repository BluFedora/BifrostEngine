The behavior system should NOT rely on Ctors and Dtors.

Rather Behaviors must have a ctor that takes in nothing.

Like Unity we should have:

[https://docs.unity3d.com/Manual/ExecutionOrder.html]
> Awake  - The first time the object is made active (called before Start).
> Start  - Called the first frame that this Behavior is active.
> Update - Called every frame on an active behavior.

The separation between Awake and Start is that with Awake you do some initializaton but you cannot assume other Behaviors have been initialized.
Then in Start you can assume all 'Awake's have been called so that you can do some inter object communication.

* Unity Requires that script files have a class with the same name as the file otherwise there is a rejection of adding it to an object.


----- Action List Design -----

The message board is not needed since the state could have been stored in the behavior itself.
Also maybe it should have a more immediate API like the RenderGraph / FrameGraph, this would
allow more dynamic behaviors since the actions are created each frame can be put into if statements.
This is retarded because then sense of timing will be very off.

----- Scripting Language Regstry -----

Rather than an int maybe this should be an opaque handle that is really an int.
typedef int bfVMRegistrySlot;

// Psuedo Codes
int reg_slot = vm.registerMakeSlot();
vm.registryLoadFromStack(reg_slot, slot_idx);
vm.stackLoadFromRegistry(slot_idx, reg_slot);
vm.registryDestoySlot(reg_slot);


----- GameObject Lifetime -----

How Unity does it is that they have a C# reference wrapper class that just contains 
a pointer to the native object. You must still explicitly destroy Objects (ex: Object.Destroy(gam_obj))
but then what you have left is an empty husk of a reference.

// [https://blogs.unity3d.com/2014/05/16/custom-operator-should-we-keep-it/]
// [https://jacx.net/2015/11/20/dont-use-equals-null-on-unity-objects.html]
