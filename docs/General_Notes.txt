Data Structure Notes:

There are really only 2 data structures:
    1. Graphs
        a. Tree (Specialized case of Graph)
            i. Linked List (Specialized case of Tree)
    2. Arrays (Just a group of items)
All other data structures are variations on these two concepts.

TODO:
	Search for 'CUSTOM_ALLOC' for any hacks in the Vulkan Gfx Backend.

> Multiviewport / Viewport Array requires Geometry shader. So it's practically useless.

Platforms (Game Wise) that C/C++ Can Target:

Languages Per Platform;

Normal Platforms:
  0 = [  Javascript  ] Web     : C / C++ -> SDL2 + Emscripten.
  1 = [Java / Kotlin ] Android : C / C++ -> SDL2 + JNI using C linkage.
  2 = [ Swift / ObjC ] iOS     : C / C++ -> SDL2 + (Swift using C linkage || ObjC++ (ObjC is basically C with garbage added on top))
  3 = [ C + C++ / C# ] Windows : C / C++ -> (SDL2 + C/++) || (GLFW + C/++)
  4 = [C + C++ / ObjC] macOS   : C / C++ -> (SDL2 + C/++) || (GLFW + C/++)
  5 = [   C + C++    ] Linux   : C / C++ -> (SDL2 + C/++) || (GLFW + C/++)

Consoles:
  Switch   : Vulkan, OpenGL 4.5, OpenGL ES
  3DS      : OpenGL ES Subset
  PS4      : GNM (low Level) / GNMX (High Level) (Custom)
  XBox One : DirectX12

Graphics APIs:
  ///////////////////////////////////////////////////////////////
  // 0 - WebGL1     / WebGL2           /           /           //
  // 1 - OpenGL ES  / Vulkan           /           /           //
  // 2 - OpenGL ES  / Metal (MoltenVK) /           /           //
  // 4 - OpenGL 4.6 / Vulkan           / DirectX12 / DirectX11 //
  // 5 - OpenGL 4.1 / Metal (MoltenVK) /           /           //
  // 6 - OpenGL 4.6 / Vulkan           /           /           //
  ///////////////////////////////////////////////////////////////

// Another Web C++ Compiler: https://www.leaningtech.com/cheerp/

[https://github.com/KhronosGroup/OpenGL-Registry]
[https://blog.codef00.com/2014/12/06/portable-bitfields-using-c11]
[https://www.guerrilla-games.com/read/creating-a-tools-pipeline-for-horizon-zero-dawn]
[https://devblogs.nvidia.com/vulkan-dos-donts/]
[https://stackoverflow.com/questions/15275023/clang-force-loop-unroll-for-specific-loop]

MSVC Define:
https://docs.microsoft.com/en-us/cpp/standard-library/iterator-debug-level?view=vs-2019
_ITERATOR_DEBUG_LEVEL=0 if you want to have decent debug vector performance.

// Better Swap and pop
https://ourmachinery.com/post/data-structures-part-1-bulk-data/
std::swap(a[i], a[a.size() - 1]);
a.pop_back();

g++ = gcc -xc++ -lstdc++ -shared-libgcc

Compiler Option
-x <langauge>

gcc will compile: *.c/*.cpp files as C and C++ respectively.
g++ will compile: *.c/*.cpp files but they will all be treated as C++ files.
Also if you use g++ to link the object files it automatically links in the std C++ libraries (gcc does not do this).
gcc compiling C files has fewer predefined macros.
gcc compiling *.cpp and g++ compiling *.c/*.cpp files has a few extra macros.
#define __GXX_WEAK__ 1
#define __cplusplus 1
#define __DEPRECATED 1
#define __GNUG__ 4
#define __EXCEPTIONS 1
#define __private_extern__ extern

Random:
  A variant with a unique_ptr and a raw pointer to the type is a good way of having both owned and non owned resources for the same class.
  This is a bit better than storing a raw pointer with a boolean from a cognitive load perspective.

  Rigidbody should be sharing a position from the Entity it is attached to. (Easy to do since Entity memory is stable, just store a pointer to the position.)

//MSVC: You can use the /permissive- compiler option to specify standards-conforming compiler behavior. This option disables permissive behaviors, and sets the /Zc compiler options for strict conformance.

// TODO(SR):
//   This is a feature list that will be tackled
//   on a need-be basis for development of an indie engine / game.
//   [4273 lines of vm + ds]
//   * Error handling in scripts.
//   * Error throwing in native functions.
//   * Do while loop.
//   * Standard Lib
//   * Unary Not
//   * Unary Minus
//   * +=, -=, *=, /=
//   * Modulo
//   * ++x
//   * x++
//   * Switch Statements (Maybe add some pattern matching?)
//   * Preprocessor for some extra fun.
//   * Integer Div
//   * Bin / Oct / Hex Numbers
//   * Unicode chars?
//   * foreach (with user defined iterators)
//   * Ternary branch
//   * For more efficient execution all string functions must be a lib rather than on the object itself.
//   * To handle infinite loops introduce a max instrcution count.

// TODO(SR): Bifrost DS
//   * Array needs a 'shrink to fit' function to make it use less memory.

// Tide Engine Notes:
//   Singletons / Globals:
//     -> Debug Logging
//     -> GUI system
//     -> Renderer Backend
//     -> Engine (lmao)
//        * By extension a lot of the engine systems but if an engine was not global this would help?
//     -> Imgui Backend
//     -> Debug Drawer
//     -> Input System
//     -> Camera FBO
//     -> A lot of Game-play garbage
//
//  Bad Ideas That happened because of Time:
//    * The Engine has GLFW in it.
//    * The Engine relies on the editor.
/*
Critique Per Subsystem:
  -> AI:
    * Great except it used new / delete.
    * Also was put directly into Behaviors so added cost to literally every object.
    * Maybe the actions should be std::functions??Rather than inheritance.
  -> ANIMATION (Frame/SpriteSheet):
    * Seemed fine for the most part. (SpriteSheet was good)
    * Make more data private in the component (People poked around)
    * There are 3 booleans in the component. Bitfield time.
    * Maybe rather than using a 'HashTable' an array with a linear find is better? (O(N) but N is very low?)
      -> This can be a be a compiler define based off of game type.
  -> ANIMATION (Ease):
    * Badly designed API.
    * Needed a more automatic API.
    * Needed a better way to reset / play backwards.
    * Needed a better pause.
  -> ANIMATION (Parallax)
    * Terrible to interface with.
    * Very confusing variable names and editing.
    * Bounds idea was very odd. The Math used was pretty awkward.
    * I set up the bg then it got copied and pasted that means it was too hard to use.
  -> ANIMATION (Timeline)
    * One of the latest system written over the summer.
    * Overall pretty nice and modular. + Lifetime management is interesting.
    * Needs less jank serialization of tracks.
    * Needs to decide on how to manage complex animations in editor.
    * How can we use multiple objects?
    * How would the object IDs work?
    * Uses the default heap with std::make_shared<Timeline>.
    * Boolean support is very bad.
    * Bitflags for the Booleans.
    * Memory Layout is bad and the classes seem heavy.
  -> ASSET_IO (Area)
    * Fine, the way the engine used them was bad though.
    * Lifetime management was bad.
    * Bounds editor could have been better.
    * Terrible for a multi-doc setup. (Practically only 3-5 Areas max used for Project Gemini)
    * Should the Camera be per area? (Yes for multi-doc setup?)
      -> Need to decide on sematics for the 'editor' Camera.
    * Useless Path Member. Maybe to use it effectively the editor should wrap Area in a doc?
    * Assets somewhat own areas but it was kinda cumbersome.
  -> ASSET_IO (Assets + AssetHandle)
    * Works out well enough. Ref counting is a very easy paradigm.
    * The main issue comes with the inability to stream content
      since each component / entity / behavior keeps the asset alive thus loaded in memory.
  -> ASSET_IO (File / FileSystem)
    * File was fine.
    * FileSystem should have an engine abstraction.
  -> ASSET_IO (Json)
    * Good format very flexible and most bugs have been fixed.
    * Pretty Inconsistent API / Naming.
    * Need more use of a config file.
  -> ASSET_IO (Prefab)
    * V2 was better but still very raw.
    * Need to be able to override properties.
    * Editing a Prefab should be more live.
  -> ASSET_IO (Serialization)
    * Good except there should have been an abstract interface for (de/)serialization
      as a lot of the code for each path is pretty much the same.
  -> AUDIO
    * Needs to be redone completely.
    * Positional audio would have been nice.
    * Good that the component lets the behaviors declare what they want.
    * No way to transition easily.
  -> COLLISION (General + Raycast)
    * It's good, need to review the polygon code for more bugs.
    * Raycast could have a more consistent API.
  -> COMBAT
    * Good, the healthbar rendering could have been better...
  -> COMPUTE
    * TBD
  -> CORE (Engine + Gamestate)
    * Gamestate system was much to fickle and awkward.
    * The Engine maybe did too much?
    * Gamestate's need the engine in the event handle.
  -> DATA_STRUCTURES (All)
    * Very good and nice to use.
  -> DEBUG (Drawer)
    * Replace the global state with a system on the engine.
    * This was overall small, minimal and good.
  -> DEBUG (Logger)
    * Pretty good, maybe have the logger not go to screen by default.
    * The editor should have had a console.
    * Replace the global state with a system on the engine.
  -> DEBUG (Profiler)
    * NOT THREAD SAFE.
    * Better editor visualization?
  -> DEBUG (ImGui)
    * A memory leaking mess.
    * Maybe it should be an engine plugin?
    * Bad big state save and restore.
  -> ECS
    * Each system should have been the each specific folder
  -> EVENT (Event)
    * Otherwise pretty good. API for Event::data could be nicer.
    * DelegateList was a poor abstarction with pointer invalidation.
  -> EVENT (Input)
    * Replace the global state with a system on the engine.
    * Multibind would have been nice.
    * Config file based binding would be nice aswell.
  -> GRAPHICS (All?)
    * Particles      - Try out scripted particles.
    * Lighting       - Would be done differently.
    * Color          - Color8u + Color4f
    * RenderMaterial - A fairly weak abstraction could be better but how?
    * TextComponent  - Heavier Caching + Semi-awkward editing of box.
    * Texture        - Turned into a cluster f**k w/ Gifs.
    * Transform      - Could be more data oriented + quaternions are better.
    *                - Bad global Node storage.
    * Vertex         - There should be more types of verts.
    * VertexArray    - Bad abstraction. handled too much.
    * VertexBuffer   - Decent abstraction.
  -> GUI (Font)
    * Static strings / more state caching needed.
  -> GUI (UI Layout)
    * Fine could be more advance for a full editor.
    * More layout engine's (Flutter Style)
  -> MATH (All)
    * Camera issues are from other systems.
    * Leaks memory with the FBO.
    * Better 3D culling??
    * More native postprocessing.
  -> MEMORY (All)
    * Great, just needs a more consistent API cuz it's super easy to use wrong.
  -> PHYSICS (RigidBody)
    * Inconsistent API between namespace and object.
  -> PHYSICS (Collider)
    * Weird Setup API.
  -> RTTI (All)
    * Add support for functions.
  -> SCRIPTING (Lua)
    * Error handling needed to be better. Also compile times.
    * Hope Bifrost Script can be the only scripting solution we need.
  -> THREADING (All)
    * Good lib.
  -> TIDE (Config / Init)
    * This stuff should maybe be loaded from a config file.
    * Window Initilization should be out of the engine.
*/

/* GOOD:
 *  Engine Run very liked feature by designers.
 */