Multiviewport / Viewport Array requires Geometry shader. So it's practically useless.

Platforms (Game Wise) that C/C++ Can Target:

Languages Per Platform;

Normal Platforms:
  0 = [  Javascript  ] Web     : C / C++ -> SDL2 + Emscripten.
  1 = [Java / Kotlin ] Android : C / C++ -> SDL2 + JNI using C linkage.
  2 = [ Swift / ObjC ] iOS     : C / C++ -> SDL2 + (Swift using C linkage || ObjC++ (ObjC is basically C with garbage added on top))
  3 = [ C + C++ / C# ] Windows : C / C++ -> (SDL2 + C/++) || (GLFW + C/++)
  4 = [C + C++ / ObjC] macOS   : C / C++ -> (SDL2 + C/++) || (GLFW + C/++)
  5 = [   C + C++    ] Linux   : C / C++ -> (SDL2 + C/++) || (GLFW + C/++)

Consoles:
  Switch   : Vulkan, OpenGL 4.5, OpenGL ES
  3DS      : OpenGL ES Subset
  PS4      : GNM (low Level) / GNMX (High Level) (Custom)
  XBox One : DirectX12

Graphics APIs:
  ///////////////////////////////////////////////////////////////
  // 0 - WebGL1     / WebGL2           /           /           //
  // 1 - OpenGL ES  / Vulkan           /           /           //
  // 2 - OpenGL ES  / Metal (MoltenVK) /           /           //
  // 4 - OpenGL 4.6 / Vulkan           / DirectX12 / DirectX11 //
  // 5 - OpenGL 4.1 / Metal (MoltenVK) /           /           //
  // 6 - OpenGL 4.6 / Vulkan           /           /           //
  ///////////////////////////////////////////////////////////////

// Another Web C++ Compiler: https://www.leaningtech.com/cheerp/

[https://github.com/KhronosGroup/OpenGL-Registry]
[https://blog.codef00.com/2014/12/06/portable-bitfields-using-c11]
[https://www.guerrilla-games.com/read/creating-a-tools-pipeline-for-horizon-zero-dawn]
[https://devblogs.nvidia.com/vulkan-dos-donts/]
[https://stackoverflow.com/questions/15275023/clang-force-loop-unroll-for-specific-loop]

MSVC Define:
https://docs.microsoft.com/en-us/cpp/standard-library/iterator-debug-level?view=vs-2019
_ITERATOR_DEBUG_LEVEL=0 if you want to have decent debug vector performance.

// Better Swap and pop
https://ourmachinery.com/post/data-structures-part-1-bulk-data/
std::swap(a[i], a[a.size() - 1]);
a.pop_back();

g++ = gcc -xc++ -lstdc++ -shared-libgcc

Compiler Option
-x <langauge>

gcc will compile: *.c/*.cpp files as C and C++ respectively.
g++ will compile: *.c/*.cpp files but they will all be treated as C++ files.
Also if you use g++ to link the object files it automatically links in the std C++ libraries (gcc does not do this).
gcc compiling C files has fewer predefined macros.
gcc compiling *.cpp and g++ compiling *.c/*.cpp files has a few extra macros.
#define __GXX_WEAK__ 1
#define __cplusplus 1
#define __DEPRECATED 1
#define __GNUG__ 4
#define __EXCEPTIONS 1
#define __private_extern__ extern

Random:
	A variant with a unique_ptr and a raw pointer to the type is a good way of having both owned and non owned resources for the same class.
	This is a bit better than storing a raw pointer with a boolean from a cognitive load perspective.

	Rigidbody should be sharing a position from the Entity it is attached to. (Easy to do since Entity memory is stable, just store a pointer to the position.)
